#Serial
####Serial采用分代方式，年轻代使用 mark-copy（标记-复制） 算法，老年代使用 mark-sweep-compact（标记-清除-整理）算法。整个GC过程会停止所有业务线程，单线程进行垃圾回收。适合单核单线程的场景。
#Parallel
####Parallel采用分代方式，年轻代使用 标记-复制（mark-copy）算法，老年代使用 标记-清除-整理（mark-sweepcompact）算法。其设计目的是增加系统吞吐量。因为对系统资源的有效使用，能达到更高的吞吐量：在 GC 期间，所有 CPU 内核都在并行清理垃圾，所以总暂停时间更短。在两次 GC 周期的间隔期，没有 GC 线程在运行，不会消耗任何系统资源。整个GC过程会停止所有的业务线程，默认使用与CPU核心数的线程进行垃圾回收。适合优先吞吐量，延迟要求不高的场景。
#CMS
####CMS主要解决问题是减少老年代暂停时间。依然采用分代方式，年轻代使用标记复制算法，而老年代通过不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收和 mark-and-sweep （标记-清除） 阶段的大部分工作和应用线程一起并发执行的方式减少暂停。默认情况下，CMS 使用的并发线程数等于 CPU 核心数的 1/4。适合B/S服务应用，降低系统的延迟。
####CMS的垃圾回收过程：
####1.Initial Mark（初始标记）：这个阶段伴随着 STW 暂停。初始标记的目标是标记所有的根对象，包括根对象直接引用的对象，以及被年轻代中所有存活对象所引用的对象（老年代单独回收）
####2.Concurrent Mark（并发标记）：在此阶段，CMS GC遍历老年代，标记所有的存活对象，从前一阶段 “Initial Mark” 找到的根对象开始算起。 “并发标记”阶段，就是与应用程序同时运行，不用暂停的阶段。
####3.Concurrent Preclean（并发预清理）：此阶段同样是与应用线程并发执行的，不需要停止应用线程。 因为前一阶段【并发标记】与程序并发运行，可能有一些引用关系已经发生了改变。如果在并发标记过程中引用关系发生了变化，JVM 会通过“Card（卡片）”的方式将发生了改变的区域标记为“脏”区，这就是所谓的 卡片标记（Card Marking）。
####4.Final Remark（最终标记）：最终标记阶段是此次 GC 事件中的第二次（也是最后一次）STW 停顿。本阶段的目标是完成老年代中所有存活对象的标记. 因为之前的预清理阶段是并发执行的，有可能 GC 线程跟不上应用程序的修改速度。所以需要一次STW 暂停来处理各种复杂的情况。通常 CMS 会尝试在年轻代尽可能空的情况下执行 Final Remark 阶段，以免连续触发多次 STW 事件。
####5.Concurrent Sweep（并发清除）：此阶段与应用程序并发执行，不需要 STW 停顿。JVM 在此阶段删除不再使用的对象，并回收他们占用的内存空间。
####6.Concurrent Reset（并发重置）：此阶段与应用程序并发执行，重置 CMS 算法相关的内部数据，为下一次 GC 循环做准备
#G1
####G1其设计的主要目的是替换CMS，将STW停顿的时间和分布，变成可预期且可配置的。G1是GC思想的突破，堆不再分成年轻代和老年代，而是划分为多个（通常是2048个）可以存放对象的 小块堆区域(smaller heap regions)。每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor区或者Old区。在逻辑上，所有的Eden区和Survivor区合起来就是年轻代，所有的Old区拼在一起那就是老年代。这样划分之后，使得 G1不必每次都去收集整个堆空间，而是以增量的方式来进行处理: 每次只处理一部分内存块，称为此次GC的回收集(collection set)。每次GC暂停都会收集所有年轻代的内存块，但一般只包含部分老年代的内存块。G1的另一项创新是，在并发阶段估算每个小堆块存活对象的总数。构建回收集的原则是：垃圾最多的小块会被优先收集。这也是G1名称的由来。
####G1的垃圾回收阶段：
####1.年轻代模式转移暂停（Evacuation Pause）：G1 GC会通过前面一段时间的运行情况来不断的调整自己的回收策略和行为，以此来比较稳定地控制暂停时间。在应用程序刚启动时，G1还没有采集到什么足够的信息，这时候就处于初始的 fullyyoung 模式。当年轻代空间用满后，应用线程会被暂停，年轻代内存块中的存活对象被拷贝到存活区。如果还没有存活区，则任意选择一部分空闲的内存块作为存活区。拷贝的过程称为转移(Evacuation)。
####2.并发标记（Concurrent Marking）：G1并发标记的过程与CMS基本上是一样的。G1的并发标记通过 Snapshot-At-The-Beginning(起始快照) 的方式，在标记阶段开始时记下所有的存活对象。即使在标记的同时又有一些变成了垃圾。通过对象的存活信息，可以构建出每个小堆块的存活状态，以便回收集能高效地进行选择。这些信息在接下来的阶段会用来执行老年代区域的垃圾收集。有两种情况是可以完全并发执行的： 一、如果在标记阶段确定某个小堆块中没有存活对象，只包含垃圾；二、在STW转移暂停期间，同时包含垃圾和存活对象的老年代小堆块。当堆内存的总体使用比例达到一定数值，就会触发并发标记。这个默认比例是 45%，但也可以通过JVM参数 InitiatingHeapOccupancyPercent 来设置。和CMS一样，G1的并发标记也是由多个阶段组成，其中一些阶段是完全并发的，还有一些阶段则会暂停应用线程。
####3.转移暂停: 混合模式（Evacuation Pause (mixed)）：并发标记完成之后，G1将执行一次混合收集（mixed collection），就是不只清理年轻代，还将一部分老年代区域也加入到 回收集 中。混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历史数据会影响混合模式的启动时机。比如，假若在老年代中可以并发地腾出很多的小堆块，就没有必要启动混合模式。因此，在并发标记与混合转移暂停之间，很可能会存在多次 young 模式的转移暂停。具体添加到回收集的老年代小堆块的大小及顺序，也是基于许多规则来判定的。其中包括指定的软实时性能指标，存活性，以及在并发标记期间收集的GC效率等数据，外加一些可配置的JVM选项。混合收集的过程，很大程度上和前面的fully-young gc是一样的
#####G1并发标记过程：
#####1.Initial Mark(初始标记)：此阶段标记所有从GC根对象直接可达的对象。
#####2.Root Region Scan(Root区扫描)：此阶段标记所有从 "根区域" 可达的存活对象。根区域包括：非空的区域，以及在标记过程中不得不收集的区域。
#####3.Concurrent Mark(并发标记)：此阶段和CMS的并发标记阶段非常类似：只遍历对象图，并在一个特殊的位图中标记能访问到的对象
#####4.Remark(再次标记)：和CMS类似，这是一次STW停顿(因为不是并发的阶段)，以完成标记过程。 G1收集器会短暂地停止应用线程，停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标记开始时未被标记的存活对象
#####5.Cleanup(清理)：最后这个清理阶段为即将到来的转移阶段做准备，统计小堆块中所有存活的对象，并将小堆块进行排序，以提升GC的效率，维护并发标记的内部状态。 所有不包含存活对象的小堆块在此阶段都被回收了。有一部分任务是并发的：例如空堆区的回收，还有大部分的存活率计算。此阶段也需要一个短暂的STW暂停

#实测数据总结
#####1、一定范围内增大堆空间，能减少GC次数，增加系统吞吐量，但是也增加了单次GC的时间
#####2、G1在堆内存大于4G的时候优势明显
