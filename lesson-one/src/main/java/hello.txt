Classfile /E:/git/my/java-advanced/lesson-one/src/main/java/Hello.class
  Last modified 2020年10月17日; size 2814 bytes
  SHA-256 checksum 6b1f2c67b1a4f340448d1ad2edb60d93aed7525c398087ee9c05f8a99caa4da8
  Compiled from "Hello.java"

//解析说明：class文件整体结构
                类型	名称	说明	长度
                u4	magic	魔数，识别Class文件格式	4个字节
                u2	minor_version	副版本号	2个字节
                u2	major_version	主版本号	2个字节
                u2	constant_pool_count	常量池计算器	2个字节
                cp_info	constant_pool	常量池	n个字节
                u2	access_flags	访问标志	2个字节
                u2	this_class	类索引	2个字节
                u2	super_class	父类索引	2个字节
                u2	interfaces_count	接口计数器	2个字节
                u2	interfaces	接口索引集合	2个字节
                u2	fields_count	字段个数	2个字节
                field_info	fields	字段集合	n个字节
                u2	methods_count	方法计数器	2个字节
                method_info	methods	方法集合	n个字节
                u2	attributes_count	附加属性计数器	2个字节
                attribute_info	attributes	附加属性集合	n个字节

public class Hello
  minor version: 0 //解析说明：副版本号为0
  major version: 59 //解析说明：主版本号为59
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER //解析说明：访问标志，ACC_PUBLIC代表类是public，ACC_SUPER表示可以使用invokespecial字节码指令
  this_class: #7                          // Hello //解析说明：类索引为#7，该值是对常量池中某个常量的一个有效索引值，该索引是一个CONSTANT_Class_info类型的结构体，表示这个class文件所定义的类和接口
  super_class: #2                         // java/lang/Object //解析说明：父类索引#2，同this_class,如果值为0则表示是没有父类的java.lang.Object类
  interfaces: 0, fields: 5, methods: 13, attributes: 4 //解析说明：0个接口、5个属性、13个方法、4个类文件属性

//解析说明：常量池表，常量表种的每项都是一个表，结构如下
                类型	标志	描述
                CONSTANT_utf8_info	1	UTF-8编码的字符串
                CONSTANT_Integer_info	3	整形字面量
                CONSTANT_Float_info	4	浮点型字面量
                CONSTANT_Long_info	5	长整型字面量
                CONSTANT_Double_info	6	双精度浮点型字面量
                CONSTANT_Class_info	7	类或接口的符号引用
                CONSTANT_String_info	8	字符串类型字面量
                CONSTANT_Fieldref_info	9	字段的符号引用
                CONSTANT_Methodref_info	10	类中方法的符号引用
                CONSTANT_InterfaceMethodref_info	11	接口中方法的符号引用
                CONSTANT_NameAndType_info	12	字段或方法的符号引用
                CONSTANT_MethodHandle_info	15	表示方法句柄
                CONSTANT_MothodType_info	16	标志方法类型
                CONSTANT_InvokeDynamic_info	18	表示一个动态方法调用点

//解析说明：常量项的表结构如下

                CONSTANT_Utf8_info {
                    u1 tag;
                    u2 length;
                    u1 bytes[length];
                }

                CONSTANT_Integer_info {
                    u1 tag;
                    u4 bytes;
                }

                CONSTANT_Float_info {
                    u1 tag;
                    u4 bytes;
                }

                CONSTANT_Long_info {
                    u1 tag;
                    u4 high_bytes;
                    u4 low_bytes;
                }

                CONSTANT_Double_info {
                    u1 tag;
                    u4 high_bytes;
                    u4 low_bytes;
                }

                CONSTANT_Class_info {
                    u1 tag;
                    u2 name_index;
                }

                CONSTANT_String_info {
                    u1 tag;
                    u2 string_index;
                }

                CONSTANT_Fieldref_info {
                    u1 tag;
                    u2 class_index;
                    u2 name_and_type_index;
                }

                CONSTANT_Methodref_info {
                    u1 tag;
                    u2 class_index;
                    u2 name_and_type_index;
                }

                CONSTANT_InterfaceMethodref_info {
                    u1 tag;
                    u2 class_index;
                    u2 name_and_type_index;
                }

                CONSTANT_NameAndType_info {
                    u1 tag;
                    u2 name_index;
                    u2 descriptor_index;
                }

                CONSTANT_MethodHandle_info {
                    u1 tag;
                    u1 reference_kind;
                    u2 reference_index;
                }

                CONSTANT_MethodType_info {
                    u1 tag;
                    u2 descriptor_index;
                }

                CONSTANT_InvokeDynamic_info {
                    u1 tag;
                    u2 bootstrap_method_attr_index;
                    u2 name_and_type_index;
                }


Constant pool:
    #1 = Methodref          #2.#3         // java/lang/Object."<init>":()V  //解析说明：符号引用指向 java/lang/Object."<init>":()V
    #2 = Class              #4            // java/lang/Object //解析说明：符号引用指向全限定名 java/lang/Object常量项的索引
    #3 = NameAndType        #5:#6         // "<init>":()V //解析说明：符号引用指向<init>方法名称、描述符的索引
    #4 = Utf8               java/lang/Object //解析说明：Utf8编码字符串java/lang/Object
    #5 = Utf8               <init>        //解析说明：Utf8编码字符串<init>
    #6 = Utf8               ()V           //解析说明：Utf8编码字符串()V
    #7 = Class              #8            // Hello //解析说明：类符号引用指向Hello类名称索引
    #8 = Utf8               Hello         //解析说明：Utf8编码字符串Hello
    #9 = Methodref          #7.#3         // Hello."<init>":()V  //解析说明：方法符号引用指向Hello."<init>":()V
   #10 = String             #11           // hello world //解析说明：字符串类型字面量索引指向hello world
   #11 = Utf8               hello world   //解析说明：Utf8编码字符串hello world
   #12 = Methodref          #7.#13        // Hello.say:(Ljava/lang/String;)V //解析说明：方法符号引用指向Hello.say:(Ljava/lang/String;)V
   #13 = NameAndType        #14:#15       // say:(Ljava/lang/String;)V //解析说明：方法符号引用
   #14 = Utf8               say           //解析说明：Utf8编码字符串say
   #15 = Utf8               (Ljava/lang/String;)V  //解析说明：Utf8编码字符串(Ljava/lang/String;)V
   #16 = Methodref          #7.#17        // Hello.add:(II)I
   #17 = NameAndType        #18:#19       // add:(II)I
   #18 = Utf8               add
   #19 = Utf8               (II)I
   #20 = Integer            1000000       //解析说明：整形字面量
   #21 = Methodref          #7.#22        // Hello.sub:(II)I
   #22 = NameAndType        #23:#19       // sub:(II)I
   #23 = Utf8               sub
   #24 = Methodref          #7.#25        // Hello.mul:(II)I
   #25 = NameAndType        #26:#19       // mul:(II)I
   #26 = Utf8               mul
   #27 = Methodref          #7.#28        // Hello.div:(II)I
   #28 = NameAndType        #29:#19       // div:(II)I
   #29 = Utf8               div
   #30 = Methodref          #7.#31        // Hello.re:(II)I
   #31 = NameAndType        #32:#19       // re:(II)I
   #32 = Utf8               re
   #33 = Methodref          #7.#34        // Hello.testForLoop:()V
   #34 = NameAndType        #35:#6        // testForLoop:()V
   #35 = Utf8               testForLoop
   #36 = Methodref          #7.#37        // Hello.testForeachLoop:()V
   #37 = NameAndType        #38:#6        // testForeachLoop:()V
   #38 = Utf8               testForeachLoop
   #39 = Methodref          #7.#40        // Hello.testTryCatchException:()V
   #40 = NameAndType        #41:#6        // testTryCatchException:()V
   #41 = Utf8               testTryCatchException
   #42 = String             #43           // apple
   #43 = Utf8               apple
   #44 = Methodref          #7.#45        // Hello.testThrowRuntimeException:(Ljava/lang/String;)V
   #45 = NameAndType        #46:#15       // testThrowRuntimeException:(Ljava/lang/String;)V
   #46 = Utf8               testThrowRuntimeException
   #47 = Methodref          #7.#48        // Hello.testSynchronized:()V
   #48 = NameAndType        #49:#6        // testSynchronized:()V
   #49 = Utf8               testSynchronized
   #50 = Class              #51           // Hello$InnerClassTest1
   #51 = Utf8               Hello$InnerClassTest1
   #52 = Methodref          #53.#54       // java/util/Objects.requireNonNull:(Ljava/lang/Object;)Ljava/lang/Object;
   #53 = Class              #55           // java/util/Objects
   #54 = NameAndType        #56:#57       // requireNonNull:(Ljava/lang/Object;)Ljava/lang/Object;
   #55 = Utf8               java/util/Objects
   #56 = Utf8               requireNonNull
   #57 = Utf8               (Ljava/lang/Object;)Ljava/lang/Object;
   #58 = Methodref          #50.#59       // Hello$InnerClassTest1."<init>":(LHello;)V
   #59 = NameAndType        #5:#60        // "<init>":(LHello;)V
   #60 = Utf8               (LHello;)V
   #61 = String             #62           // moon
   #62 = Utf8               moon
   #63 = Fieldref           #50.#64       // Hello$InnerClassTest1.name:Ljava/lang/String;
   #64 = NameAndType        #65:#66       // name:Ljava/lang/String;
   #65 = Utf8               name
   #66 = Utf8               Ljava/lang/String;
   #67 = Methodref          #50.#68       // Hello$InnerClassTest1.greet:()V
   #68 = NameAndType        #69:#6        // greet:()V
   #69 = Utf8               greet
   #70 = Class              #71           // Hello$InnerClassTest2
   #71 = Utf8               Hello$InnerClassTest2
   #72 = Methodref          #70.#3        // Hello$InnerClassTest2."<init>":()V
   #73 = String             #74           // sky
   #74 = Utf8               sky
   #75 = Fieldref           #70.#64       // Hello$InnerClassTest2.name:Ljava/lang/String;
   #76 = Methodref          #70.#68       // Hello$InnerClassTest2.greet:()V
   #77 = Fieldref           #78.#79       // java/lang/System.out:Ljava/io/PrintStream;
   #78 = Class              #80           // java/lang/System
   #79 = NameAndType        #81:#82       // out:Ljava/io/PrintStream;
   #80 = Utf8               java/lang/System
   #81 = Utf8               out
   #82 = Utf8               Ljava/io/PrintStream;
   #83 = Methodref          #84.#85       // java/io/PrintStream.println:(Ljava/lang/String;)V
   #84 = Class              #86           // java/io/PrintStream
   #85 = NameAndType        #87:#15       // println:(Ljava/lang/String;)V
   #86 = Utf8               java/io/PrintStream
   #87 = Utf8               println
   #88 = InvokeDynamic      #0:#89        // #0:makeConcatWithConstants:(I)Ljava/lang/String; //解析说明：动态方法调用点
   #89 = NameAndType        #90:#91       // makeConcatWithConstants:(I)Ljava/lang/String;
   #90 = Utf8               makeConcatWithConstants
   #91 = Utf8               (I)Ljava/lang/String;
   #92 = InvokeDynamic      #1:#89        // #1:makeConcatWithConstants:(I)Ljava/lang/String;
   #93 = Long               100l
   #95 = Methodref          #96.#97       // java/lang/Thread.sleep:(J)V
   #96 = Class              #98           // java/lang/Thread
   #97 = NameAndType        #99:#100      // sleep:(J)V
   #98 = Utf8               java/lang/Thread
   #99 = Utf8               sleep
  #100 = Utf8               (J)V
  #101 = String             #102          // finally
  #102 = Utf8               finally
  #103 = Class              #104          // java/lang/InterruptedException
  #104 = Utf8               java/lang/InterruptedException
  #105 = Methodref          #103.#106     // java/lang/InterruptedException.printStackTrace:()V
  #106 = NameAndType        #107:#6       // printStackTrace:()V
  #107 = Utf8               printStackTracec
  #108 = Fieldref           #7.#109       // Hello.a:I
  #109 = NameAndType        #110:#111     // a:I
  #110 = Utf8               a
  #111 = Utf8               I
  #112 = Class              #113          // java/lang/IllegalStateException
  #113 = Utf8               java/lang/IllegalStateException
  #114 = String             #115          // a illegalState exception
  #115 = Utf8               a illegalState exception
  #116 = Methodref          #112.#117     // java/lang/IllegalStateException."<init>":(Ljava/lang/String;)V
  #117 = NameAndType        #5:#15        // "<init>":(Ljava/lang/String;)V
  #118 = Utf8               b
  #119 = Utf8               c
  #120 = Utf8               ConstantValue
  #121 = Integer            3
  #122 = Utf8               d
  #123 = Integer            4
  #124 = Utf8               f
  #125 = Utf8               D
  #126 = Utf8               Code
  #127 = Utf8               LineNumberTable
  #128 = Utf8               main
  #129 = Utf8               ([Ljava/lang/String;)V
  #130 = Utf8               StackMapTable
  #131 = Class              #132          // "[I"
  #132 = Utf8               [I
  #133 = Class              #134          // java/lang/Throwable
  #134 = Utf8               java/lang/Throwable
  #135 = Utf8               SourceFile
  #136 = Utf8               Hello.java
  #137 = Utf8               NestMembers
  #138 = Utf8               BootstrapMethods
  #139 = MethodHandle       6:#140        // REF_invokeStatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite; //解释说明:表示方法句柄
  #140 = Methodref          #141.#142     // java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;
  #141 = Class              #143          // java/lang/invoke/StringConcatFactory
  #142 = NameAndType        #90:#144      // makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;
  #143 = Utf8               java/lang/invoke/StringConcatFactory
  #144 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;
  #145 = String             #146          // for loop i = \u0001
  #146 = Utf8               for loop i = \u0001
  #147 = String             #148          // foreach loop i = \u0001
  #148 = Utf8               foreach loop i = \u0001
  #149 = Utf8               InnerClasses
  #150 = Utf8               InnerClassTest1
  #151 = Utf8               InnerClassTest2
  #152 = Class              #153          // java/lang/invoke/MethodHandles$Lookup
  #153 = Utf8               java/lang/invoke/MethodHandles$Lookup
  #154 = Class              #155          // java/lang/invoke/MethodHandles
  #155 = Utf8               java/lang/invoke/MethodHandles
  #156 = Utf8               Lookup

//解释说明：字段表
        类型	名称	含义
        u2	access_flags	访问标志
        u2	name_index	字段名索引
        u2	descriptor_index	描述符索引
        u2	attributes_count	属性计数器
        attribute_info	attributes	属性集合

        注意事项
        1、字段表集合中不会列出从父类或者父接口中继承而来的字段。
        2、内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。
        3、在Java语言中字段是无法重载的，两个字段的数据类型，修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的．

{
  public static int b;
    descriptor: I //解释说明：类型为int
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC //解释说明：访问标志public、static

  public static final int c;
    descriptor: I //解释说明：类型为int
    flags: (0x0019) ACC_PUBLIC, ACC_STATIC, ACC_FINAL //解释说明：访问标志public、static、final
    ConstantValue: int 3 // 字面常量为3

//解释说明：方法表
        类型	名称	含义
        u2	access_flags	访问标志
        u2	name_index	方法名索引
        u2	descriptor_index	描述符索引
        u2	attributes_count	属性计数器
        attribute_info	attributes	属性集合

        属性表：
        类型	名称	数量	含义
        u2	attribute_name_index	1	属性名索引
        u2	attribute_length	1	属性长度
        u1	info	attribute_length	属性表

        属性类型：
        属性名称	使用位置	含义
        Code	方法表	Java代码编译成的字节码指令
        ConstantValue	字段表	final关键字定义的常量池
        Deprecated	类，方法，字段表	被声明为deprecated的方法和字段
        Exceptions	方法表	方法抛出的异常
        EnclosingMethod	类文件	仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法
        InnerClass	类文件	内部类列表
        LineNumberTable	Code属性	Java源码的行号与字节码指令的对应关系
        LocalVariableTable	Code属性	方法的局部变量描述
        StackMapTable	Code属性	JDK1.6中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配
        Signature	类，方法表，字段表	用于支持泛型情况下的方法签名
        SourceFile	类文件	记录源文件名称
        SourceDebugExtension	类文件	用于存储额外的调试信息
        Synthetic	类，方法表，字段表	标志方法或字段为编译器自动生成的
        LocalVariableTypeTable	类	使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加
        RuntimeVisibleAnnotations	类，方法表，字段表	为动态注解提供支持
        RuntimeInvisibleAnnotations	表，方法表，字段表	用于指明哪些注解是运行时不可见的
        RuntimeVisibleParameterAnnotation	方法表	作用与RuntimeVisibleAnnotations属性类似，只不过作用对象为方法
        RuntimeInvisibleParameterAnnotation	方法表	作用与RuntimeInvisibleAnnotations属性类似，作用对象哪个为方法参数
        AnnotationDefault	方法表	用于记录注解类元素的默认值
        BootstrapMethods	类文件	用于保存invokeddynamic指令引用的引导方式限定符

        Code表结构：
        类型	名称	含义
        u2	attribute_name_index 属性名索引
        u4	attribute_length	属性长度
        u2	max_stack	操作数栈深度的最大值
        u2	max_locals	局部变量表所需的存续空间
        u4	code_length	字节码指令的长度
        u1	code	code_length	存储字节码指令
        u2	exception_table_length	异常表长度
        exception_info	exception_table	exception_length	异常表
        u2	attributes_count	属性集合计数器
        attribute_info	attributes	attributes_count	属性集合

        LineNumberTable表结构：
        类型	名称	含义
        u2	attribute_name_index	属性名索引
        u4	attribute_length	属性长度
        u2	line_number_table_length	行号表长度
        line_number_info	line_number_table	line_number_table_length	行号表

  public Hello();
    descriptor: ()V //解释说明：无参无返回值
    flags: (0x0001) ACC_PUBLIC //解释说明：访问标记public
    Code: //解释说明：code属性表
      stack=1, locals=1, args_size=1 // 解释说明：栈深度1，局部变量表长度1，参数个数1
         0: aload_0   //解释说明：将第0个Slot中为reference类型的本地变量推送到操作数栈顶，这里是将this推送到栈顶
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V //解释说明：将操作数栈顶的reference类型数据所指向的对象作为方法接收者，调用此对象的实例方法、private方法或者他的父类方法。这里是调用父类Object的<init>方法
         4: return // 解释说明：回此方法，并且返回值为void。这条指令执行完后，当前的方法也就结束了
      LineNumberTable: //解释说明：LineNumberTable表，Java源码的行号与字节码指令的对应关系
        line 1: 0 //解释说明：字节码第0行对应源码第一行

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V //解释说明：参数是String对象数组，没有返回值
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC //解释说明：访问标志public、static
    Code:
      stack=4, locals=4, args_size=1
         0: new           #7                  // class Hello //解释说明：创建一个对象，并将其引用值压入栈顶
         3: dup                                // 解释说明：复制栈顶数值并将复制值压入栈顶
         4: invokespecial #9                  // Method "<init>":()V //解释说明：
         7: astore_1                          //解释说明：将栈顶引用型数值存入第二个本地变量
         8: aload_1                           //解释说明：将第二个引用类型本地变量推送到栈顶
         9: ldc           #10                 // String hello world //解释说明：将int, float或String型常量值从常量池中推送至栈顶
        11: invokevirtual #12                 // Method say:(Ljava/lang/String;)V //解释说明：调用超类构造方法，实例初始化方法，私有方法
        14: iconst_1  //解释说明：将int型1推送至栈顶
        15: iconst_2  //解释说明：将int型2推送至栈顶
        16: invokestatic  #16                 // Method add:(II)I //解释说明：调用静态方法
        19: pop   //解释说明：将栈顶数值弹出 (数值不能是long或do le类型的)
        20: ldc           #20                 // int 1000000 //解释说明：将int, float或String型常量值从常量池中推送至栈顶
        22: bipush        20 //解释说明：将单字节的常量值(-128~127)推送至栈顶
        24: invokestatic  #21                 // Method sub:(II)I //解释说明：调用静态方法
        27: pop
        28: sipush        1000    //解释说明：将一个短整型常量值(-32768~32767)推送至栈顶
        31: sipush        2000
        34: invokestatic  #24                 // Method mul:(II)I
        37: pop
        38: sipush        500
        41: iconst_3
        42: invokestatic  #27                 // Method div:(II)I
        45: pop
        46: bipush        10
        48: iconst_3
        49: invokestatic  #30                 // Method re:(II)I
        52: pop
        53: aload_1
        54: invokevirtual #33                 // Method testForLoop:()V
        57: aload_1
        58: invokevirtual #36                 // Method testForeachLoop:()V
        61: aload_1
        62: invokevirtual #39                 // Method testTryCatchException:()V
        65: aload_1
        66: ldc           #42                 // String apple
        68: invokevirtual #44                 // Method testThrowRuntimeException:(Ljava/lang/String;)V
        71: aload_1
        72: invokevirtual #47                 // Method testSynchronized:()V
        75: new           #50                 // class Hello$InnerClassTest1
        78: dup
        79: aload_1
        80: dup
        81: invokestatic  #52                 // Method java/util/Objects.requireNonNull:(Ljava/lang/Object;)Ljava/lang/Object;
        84: pop
        85: invokespecial #58                 // Method Hello$InnerClassTest1."<init>":(LHello;)V
        88: astore_2
        89: aload_2
        90: ldc           #61                 // String moon
        92: putfield      #63                 // Field Hello$InnerClassTest1.name:Ljava/lang/String;  //解释说明：为指定的类的实例域赋值
        95: aload_2
        96: invokevirtual #67                 // Method Hello$InnerClassTest1.greet:()V
        99: new           #70                 // class Hello$InnerClassTest2
       102: dup
       103: invokespecial #72                 // Method Hello$InnerClassTest2."<init>":()V
       106: astore_3
       107: aload_3
       108: ldc           #73                 // String sky
       110: putfield      #75                 // Field Hello$InnerClassTest2.name:Ljava/lang/String;
       113: aload_3
       114: invokevirtual #76                 // Method Hello$InnerClassTest2.greet:()V
       117: return
      LineNumberTable:
        line 10: 0
        line 11: 8
        line 12: 14
        line 13: 20
        line 14: 28
        line 15: 38
        line 16: 46
        line 17: 53
        line 18: 57
        line 19: 61
        line 20: 65
        line 21: 71
        line 22: 75
        line 23: 89
        line 24: 95
        line 25: 99
        line 26: 107
        line 27: 113
        line 28: 117

  public void say(java.lang.String);
    descriptor: (Ljava/lang/String;)V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: getstatic     #77                 // Field java/lang/System.out:Ljava/io/PrintStream; //解释说明：获取指定类的静态域，并将其值压入栈顶
         3: aload_1
         4: invokevirtual #83                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         7: return
      LineNumberTable:
        line 31: 0
        line 32: 7

  public static int add(int, int);
    descriptor: (II)I
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=2
         0: iload_0
         1: iload_1
         2: iadd
         3: ireturn
      LineNumberTable:
        line 35: 0

  public static int sub(int, int);
    descriptor: (II)I
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=2
         0: iload_0
         1: iload_1
         2: isub  //解释说明：将栈顶两int型数值相减并将结果压入栈顶
         3: ireturn //解释说明：从当前方法返回int
      LineNumberTable:
        line 39: 0

  public static int mul(int, int);
    descriptor: (II)I
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=2
         0: iload_0
         1: iload_1
         2: imul  //解释说明：将栈顶两int型数值相乘并将结果压入栈顶
         3: ireturn
      LineNumberTable:
        line 43: 0

  public static int div(int, int);
    descriptor: (II)I
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=2
         0: iload_0
         1: iload_1
         2: idiv //解释说明：将栈顶两int型数值相除并将结果压入栈顶
         3: ireturn
      LineNumberTable:
        line 47: 0

  public static int re(int, int);
    descriptor: (II)I
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=2
         0: iload_0
         1: iload_1
         2: irem
         3: ireturn
      LineNumberTable:
        line 51: 0

  public void testForLoop();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=1
         0: iconst_0
         1: istore_1
         2: iload_1
         3: bipush        10
         5: if_icmpge     26
         8: getstatic     #77                 // Field java/lang/System.out:Ljava/io/PrintStream;
        11: iload_1
        12: invokedynamic #88,  0             // InvokeDynamic #0:makeConcatWithConstants:(I)Ljava/lang/String;
        17: invokevirtual #83                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        20: iinc          1, 1   //解释说明：将指定int型变量增加指定值（i++, i–, i+=2）
        23: goto          2      //解释说明：无条件跳转
        26: return
      LineNumberTable:
        line 55: 0
        line 56: 8
        line 55: 20
        line 58: 26

      //解释说明：栈图（在Java 6版本之后JVM在class文件中引入了栈图(StackMapTable)属性。作用是为了提高JVM在类型检查的验证过程的效率）
        StackMapTable_attribute {
            u2              attribute_name_index; 对应的是常量池表的一个有效索引。也即CONSTANT_Utf8_info结构中表示“StackMapTable”的索引
            u4              attribute_length; 标识当前属性的长度（排除前六个字节）
            u2              number_of_entries; 表示entries表的成员数量。entries表中的所有成员都是一个stack_map_frame结构
            stack_map_frame entries[number_of_entries]; 表中的每一项都表示本方法的一个stack map frame，并且表中每一项都是有序的
        }

      StackMapTable: number_of_entries = 2
        frame_type = 252 /* append */
          offset_delta = 2
          locals = [ int ]
        frame_type = 250 /* chop */
          offset_delta = 23

  public void testForeachLoop();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=4, locals=6, args_size=1
         0: iconst_3
         1: newarray       int //解释说明：创建一个指定原始类型（如int, float, char…）的数组，并将其引用值压入栈顶
         3: dup
         4: iconst_0
         5: iconst_1
         6: iastore  //解释说明：将栈顶int型数值存入指定数组的指定索引位置，这里是把栈顶1存入数组下标为0的位置
         7: dup
         8: iconst_1
         9: iconst_2
        10: iastore
        11: dup
        12: iconst_2
        13: iconst_3
        14: iastore
        15: astore_1
        16: aload_1
        17: astore_2
        18: aload_2
        19: arraylength //解释说明：获得数组的长度值并压入栈顶
        20: istore_3
        21: iconst_0
        22: istore        4
        24: iload         4
        26: iload_3
        27: if_icmpge     55
        30: aload_2
        31: iload         4
        33: iaload
        34: istore        5
        36: getstatic     #77                 // Field java/lang/System.out:Ljava/io/PrintStream;
        39: iload         5
        41: invokedynamic #92,  0             // InvokeDynamic #1:makeConcatWithConstants:(I)Ljava/lang/String;
        46: invokevirtual #83                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        49: iinc          4, 1
        52: goto          24
        55: return
      LineNumberTable:
        line 61: 0
        line 62: 16
        line 63: 36
        line 62: 49
        line 65: 55
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 24
          locals = [ class Hello, class "[I", class "[I", int, int ]
          stack = []
        frame_type = 248 /* chop */
          offset_delta = 30

  public synchronized void testSynchronized();
    descriptor: ()V
    flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED //解释说明：方法标志为public、synchronized
    Code:
      stack=3, locals=1, args_size=1
         0: aload_0
         1: dup
         2: getfield      #108                // Field a:I
         5: iconst_1
         6: iadd
         7: putfield      #108                // Field a:I
        10: return
      LineNumberTable:
        line 78: 0
        line 79: 10
}
SourceFile: "Hello.java" //解释说明：ClassFile结构的属性表、源代码文件名
NestMembers:
  Hello$InnerClassTest2
  Hello$InnerClassTest1

//解释说明：位于ClassFile结构的属性表中，用于保存invokedynamic指令引用的引导方法限定符，如果常量池中包含CONSTANT_InvokeDynamic_info成员，则ClassFile的属性表中必须包含且只能包含一个BootstrapMethods属性
BootstrapMethods:
  0: #139 REF_invokeStatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;
    Method arguments:
      #145 for loop i = \u0001
  1: #139 REF_invokeStatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;
    Method arguments:
      #147 foreach loop i = \u0001
InnerClasses: //解释说明：位于ClassFile的属性表中，表示该类定义的内部类信息，如果有内部类，则有且仅有一个InnerClasses属性
  #150= #50 of #7;                        // InnerClassTest1=class Hello$InnerClassTest1 of class Hello
  static #151= #70 of #7;                 // InnerClassTest2=class Hello$InnerClassTest2 of class Hello
  public static final #156= #152 of #154; // Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles